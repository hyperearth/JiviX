#version 460 core // #
#extension GL_GOOGLE_include_directive          : require
#include "./driver.glsl"

// 
//layout ( location = 0 ) in vec2 vcoord;
//layout ( location = 0 ) out vec4 uFragColor;
layout (local_size_x = 32u, local_size_y = 24u) in; 

// Not Reprojected by Previous Frame
vec4 getPosition   (in ivec2 map) { const ivec2 size = imageSize(writeBuffer[BW_POSITION]); return imageLoad(writeBuffer[BW_POSITION],ivec2(map.x,map.y)); };
vec4 getNormal     (in ivec2 map) { const ivec2 size = imageSize(writeImages[IW_MAPNORML]); return imageLoad(writeImages[IW_MAPNORML],ivec2(map.x,map.y)); };
vec4 getData       (in ivec2 map) { const ivec2 size = imageSize(writeImages[IW_MATERIAL]); return imageLoad(writeImages[IW_MATERIAL],ivec2(map.x,map.y)); };

// For current frame only
vec4 getReflection (in ivec2 map) { const ivec2 size = imageSize(writeBuffer[BW_REFLECLR]); return imageLoad(writeBuffer[BW_REFLECLR],ivec2(map.x,map.y)); };
vec4 getTransparent(in ivec2 map) { const ivec2 size = imageSize(writeBuffer[BW_TRANSPAR]); return imageLoad(writeBuffer[BW_TRANSPAR],ivec2(map.x,map.y)); };
vec4 getColor      (in ivec2 map) { const ivec2 size = imageSize(writeBuffer[BW_INDIRECT]); return imageLoad(writeBuffer[BW_INDIRECT],ivec2(map.x,map.y)); };

// With Resampling
vec4 getSmoothed   (in ivec2 map) { const ivec2 size = imageSize(writeImages[IW_SMOOTHED]); return imageLoad(writeImages[IW_SMOOTHED],ivec2(map.x,map.y)); };
vec4 getIndirect   (in ivec2 map) { const ivec2 size = imageSize(writeImages[IW_INDIRECT]); return imageLoad(writeImages[IW_INDIRECT],ivec2(map.x,map.y)); };
vec4 getPReflection(in ivec2 map) { const ivec2 size = imageSize(writeImages[IW_REFLECLR]); return imageLoad(writeImages[IW_REFLECLR],ivec2(map.x,map.y)); };

// 
void setColor      (in ivec2 map, in vec4 color) { const ivec2 size = imageSize(writeBuffer[BW_INDIRECT]); imageStore(writeBuffer[BW_INDIRECT],ivec2(map.x,map.y),color); };
void setReflection (in ivec2 map, in vec4 color) { const ivec2 size = imageSize(writeBuffer[BW_REFLECLR]); imageStore(writeBuffer[BW_REFLECLR],ivec2(map.x,map.y),color); };

// 
ivec2 mapc(in ivec2 map) {
    const ivec2 size = imageSize(writeImages[IW_REFLECLR]);
    return ivec2(map.x,size.y-map.y-1);
}

bool skyboxPixel(in ivec2 samplep) {
    const  vec4 dataflat = getData(samplep);
    const uvec4 datapass = floatBitsToUint(dataflat);
    const vec2 texcoord = unpackUnorm2x16(datapass.x);
    return uintBitsToFloat(datapass.z) <= 0.f;
}

// 
vec4 getDenoised(in ivec2 coord, in int type, in uint maxc) {
    vec4 centerNormal = getNormal(coord);
    vec3 centerOrigin = world2screen(getPosition(coord).xyz);

    vec4 sampled = 0.f.xxxx; int scount = 0;
    vec4 centerc = getIndirect(coord);

    for (uint x=0;x<maxc;x++) {
        for (uint y=0;y<maxc;y++) {
            ivec2 map = coord+ivec2(x-(maxc>>1),y-(maxc>>1));
            vec4 nsample = getNormal(map), psample = vec4(world2screen(getPosition(map).xyz), 1.f);

            if (dot(nsample.xyz,centerNormal.xyz) >= 0.5f && distance(psample.xyz,centerOrigin.xyz) < 0.01f && abs(centerOrigin.z-psample.z) < 0.005f || (x == (maxc>>1) && y == (maxc>>1)) || centerc.w <= 0.0001f && sampled.w <= 0.0001f) {
                vec4 samp = 0.f.xxxx; float simp = 1.f;
                if (type == 0) { samp = getIndirect   (map); simp = samp.w; };
                if (type == 1) { samp = getPReflection(map); simp = samp.w; };
                if (type == 2) { samp = getTransparent(map); simp = samp.w; };

                // 
                samp.xyz = clamp(samp.xyz/max(samp.w,0.5f), 0.f.xxx, type == 2 ? 2.f.xxx : 16.f.xxx)*samp.w; samp.w = simp;
                sampled += samp;
            };
        };
    };

    //if (reflection) {
    //    sampled.xyz /= sampled.w;
    //    sampled.w = getPReflection(coord).w;
    //};

    sampled.w = max(sampled.w, 1.f);
    return sampled;
};

// Checker Board BUG Fix
float fixedTranparency(in ivec2 samplep) {
    float center = getTransparent(samplep).w;
    float fixedt = center;
    float xt = getTransparent(samplep + ivec2(1, 0)).w;
    float yt = getTransparent(samplep + ivec2(0, 1)).w;

    if (fixedt < 0.0001f) { 
        if (xt > 0.0001f && yt > 0.0001f) { fixedt = .5f*(xt+ yt); } else 
                                          { fixedt =  max(xt, yt); };
    };
    return fixedt;
};


// TODO: Use Texcoord and Material ID's instead of Color, PBR-Map, Emission,  (due, needs only two or one buffers)
void main() { // TODO: explicit sampling 
    const ivec2 size = imageSize(writeImages[IW_INDIRECT]), samplep = ivec2(gl_GlobalInvocationID.xy);
    const  vec4 dataflat = getData(samplep);
    const uvec4 datapass = floatBitsToUint(dataflat);
    const  vec4 position = getPosition(samplep);

    // 
    const vec2 texcoord = unpackUnorm2x16(datapass.x);
    const bool isSkybox = uintBitsToFloat(datapass.z) <= 0.f;

    // 
    const MaterialUnit unit = materials[0u].data[datapass.y];
          vec4 diffused = toLinear(unit. diffuseTexture >= 0 ? texture(textures[nonuniformEXT(unit. diffuseTexture)],texcoord.xy) : unit.diffuse);
          vec4 emission = toLinear(unit.emissionTexture >= 0 ? texture(textures[nonuniformEXT(unit.emissionTexture)],texcoord.xy) : unit.emission);
          vec4 normaled = unit. normalsTexture >= 0 ? texture(textures[nonuniformEXT(unit. normalsTexture)],texcoord.xy) : unit.normals;
          vec4 specular = unit.specularTexture >= 0 ? texture(textures[nonuniformEXT(unit.specularTexture)],texcoord.xy) : unit.specular;
          vec4 dtexdata = diffused;

    // experimental (unused for alpha transparency)
    //if (diffused.w < 0.99f && !isSkybox) { diffused.xyz = 1.f.xxx, diffused.w = 1.f; } // doesnt't working
    //if (diffused.w < 0.99f) { diffused.xyz = 1.f.xxx; };

    // 
    const vec3 camera = vec4(position.xyz,1.f)*modelview;
    const vec3 raydir = (modelview * normalize(camera.xyz)).xyz;
    const vec3 origin = getPosition(samplep).xyz;
    const vec3 normal = getNormal(samplep).xyz;

    // Updated for 12.05.2020
    diffused.xyz = max(diffused.xyz - emission.xyz, 0.f.xxx);
    //diffused = getSmoothed(samplep), diffused /= max(diffused.w, 1.f); // BROKEN!
    diffused.w = dtexdata.w; // Replace Into Diffuse Alpha Channel

    if (isSkybox) { diffused.xyz = 0.f.xxx, emission.xyz = gSkyShader(raydir.xyz, origin.xyz).xyz; };
    
    // 
#ifndef LATE_STAGE
    vec4 reflects = vec4(0.f.xxxx);
    vec4 coloring = getDenoised(samplep, 0, 9);
#else // 
    int denDepth = 3;
    if (specular.y > 0.3333f) denDepth = 5;
    if (specular.y > 0.6666f) denDepth = 7;
    if (specular.y > 0.9999f) denDepth = 9;
    vec4 reflects = getDenoised(samplep, 1, denDepth);
    vec4 coloring = vec4(0.f.xxxx);
#endif

    // 
    if (reflects.w <= 0.f) { reflects = vec4(0.f.xxx,0.f); };
    if (coloring.w <= 0.f) { coloring = vec4(0.f.xxx,1.f); };
    coloring = max(coloring, 0.f.xxxx);
    reflects = max(reflects, 0.f.xxxx);

    // 
    const float inIOR = 1.f, outIOR = 1.6666f;
    const float frefl = mix(clamp(pow(1.0f + dot(raydir.xyz, normal.xyz), outIOR/inIOR), 0.f, 1.f) * 0.3333f, 1.f, specular.z) * (isSkybox ? 0.f : 1.f);

    // Currently NOT denoised! (impolated with previous frame)
    vec4 currentReflection = getReflection(samplep), previousReflection = getPReflection(samplep);
    previousReflection = (previousReflection/max(previousReflection.w,1.f));
     currentReflection = ( currentReflection/max( currentReflection.w,1.f));

    // 
    vec4 transpar = getDenoised(samplep, 2, 3);
    transpar.xyz /= max(transpar.w, 0.5f);
    transpar.w = diffused.w <= 0.9999f ? 1.f : 0.f;
    float alpha = clamp((transpar.w * (1.f-diffused.w)) * (isSkybox ? 0.f : 1.f), 0.f, 1.f);

#ifndef LATE_STAGE
    imageStore(writeImages[IW_REFLECLR], mapc(samplep), reflects = vec4(clamp(mix(previousReflection.xyz/max(previousReflection.w,1.f), currentReflection.xyz/max(currentReflection.w,1.f), (1.f-specular.y*0.5f)), 0.f.xxx, 1.f.xxx), 1.f)); // Smoothed Reflections
    imageStore(writeBuffer[BW_RENDERED],     (samplep), vec4((coloring.xyz/max(coloring.w,1.f))*(diffused.xyz)+max(emission.xyz,0.f.xxx),1.f));
    //imageStore(writeBuffer[BW_RENDERED],   (samplep), vec4(mix((coloring.xyz/max(coloring.w,1.f))*(diffused.xyz/max(diffused.w,1.f))+max(emission.xyz,0.f.xxx),(reflects.xyz/max(reflects.w,1.f)),frefl),1.f));

    // Copy Into Back-Side
    [[unroll]] for (uint I=0;I<12u;I++) {
        imageStore(writeImagesBack[I], mapc(samplep), imageLoad(writeImages[I], mapc(samplep)));
    };

    // Will very actual after adaptive denoise... 
    if (!isSkybox && getTransparent(samplep).w > 0.f) {
        float scount = max(imageLoad(writeImages[IW_INDIRECT], mapc(samplep)).w, 1.f);
        imageStore(writeImagesBack[IW_INDIRECT], mapc(samplep), vec4(diffused.xyz*scount, scount));
    };

#else
    imageStore(writeBuffer[BW_RENDERED],     (samplep), vec4(clamp(mix(imageLoad(writeBuffer[BW_RENDERED], samplep).xyz, transpar.xyz/max(transpar.w,0.5f), alpha), 0.f.xxx, 1.f.xxx), 1.f));
    imageStore(writeBuffer[BW_RENDERED],     (samplep), vec4(clamp(mix(imageLoad(writeBuffer[BW_RENDERED], samplep).xyz, reflects.xyz/max(reflects.w,0.5f), frefl), 0.f.xxx, 1.f.xxx), 1.f));
    //imageStore(writeBuffer[BW_RENDERED],   (samplep), vec4(mix((coloring.xyz/max(coloring.w,1.f))*(diffused.xyz/max(diffused.w,1.f))+max(emission.xyz,0.f.xxx),(reflects.xyz/max(reflects.w,1.f)),frefl),1.f));
#endif

};
