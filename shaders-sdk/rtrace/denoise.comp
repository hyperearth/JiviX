#version 460 core // #
#extension GL_GOOGLE_include_directive          : require
#include "./driver.glsl"

// 
//layout ( location = 0 ) in vec2 vcoord;
//layout ( location = 0 ) out vec4 uFragColor;
layout (local_size_x = 16u, local_size_y = 12u) in; 

// 
vec4 getIndirect   (in ivec2 map) { const ivec2 size = imageSize(writeImages[DIFFUSED]); return imageLoad(writeImages[DIFFUSED],ivec2(map.x,size.y-map.y-1)); };
vec4 getNormal     (in ivec2 map) { const ivec2 size = imageSize(writeImages[MAPNORML]); return imageLoad(writeImages[MAPNORML],ivec2(map.x,size.y-map.y-1)); };
vec4 getPosition   (in ivec2 map) { const ivec2 size = imageSize(writeImages[POSITION]); return imageLoad(writeImages[POSITION],ivec2(map.x,size.y-map.y-1)); };
vec4 getReflection (in ivec2 map) { const ivec2 size = imageSize(writeImages[REFLECLR]); return imageLoad(writeImages[REFLECLR],ivec2(map.x,size.y-map.y-1)); };
vec4 getTransparent(in ivec2 map) { const ivec2 size = imageSize(writeImages[TRANSPAR]); return imageLoad(writeImages[TRANSPAR],ivec2(map.x,size.y-map.y-1)); };

// Resampling Data
vec4 getPReflection(in ivec2 map) { const ivec2 size = imageSize(writeImages[REFLECTP]); return imageLoad(writeImages[REFLECTP],ivec2(map.x,size.y-map.y-1)); };

// 
//void setColor      (in ivec2 map, in vec4 color) { const ivec2 size = imageSize(writeImages[COLORING]); imageStore(writeImages[COLORING],ivec2(map.x,size.y-map.y-1),color); };
void setReflection (in ivec2 map, in vec4 color) { const ivec2 size = imageSize(writeImages[REFLECLR]); imageStore(writeImages[REFLECLR],ivec2(map.x,size.y-map.y-1),color); };

// FOR REPLACEMENT by Texcoord, Material ID, Data
//vec4 getEmission   (in ivec2 map) { const ivec2 size = imageSize(writeImages[EMISSION]); return imageLoad(writeImages[EMISSION],ivec2(map.x,size.y-map.y-1)); };
//vec4 getColor      (in ivec2 map) { const ivec2 size = imageSize(writeImages[COLORING]); return imageLoad(writeImages[COLORING],ivec2(map.x,size.y-map.y-1)); };
vec4 getData      (in ivec2 map) { const ivec2 size = imageSize(writeImages[MATERIAL]); return imageLoad(writeImages[MATERIAL],ivec2(map.x,size.y-map.y-1));  };

// 
ivec2 mapc(in ivec2 map) {
    const ivec2 size = imageSize(writeImages[REFLECTP]);
    return ivec2(map.x,size.y-map.y-1);
}

// 
vec4 getDenoised(in ivec2 coord, in bool reflection, in uint maxc) {
    vec4 centerNormal = getNormal(coord);
    vec3 centerOrigin = world2screen(getPosition(coord).xyz);

    vec4 sampled = 0.f.xxxx; int scount = 0;
    vec4 centerc = getIndirect(coord);
    for (uint x=0;x<maxc;x++) {
        for (uint y=0;y<maxc;y++) {
            ivec2 map = coord+ivec2(x-(maxc>>1),y-(maxc>>1));
            vec4 nsample = getNormal(map);
            vec3 psample = world2screen(getPosition(map).xyz);

            if (dot(nsample.xyz,centerNormal.xyz) >= 0.5f && distance(psample.xyz,centerOrigin.xyz) < 0.01f && abs(centerOrigin.z-psample.z) < 0.005f || (x == (maxc>>1) && y == (maxc>>1)) || centerc.w <= 0.0001f) {
                vec4 samp = 0.f.xxxx;
                if (reflection) {
                    samp = vec4(getReflection(map).xyz,1.f);
                } else {
                    samp = getIndirect(map);
                };

                sampled += samp;
                //sampled += clamp(samp/max(samp.w,1.f),0.f.xxxx,1.f.xxxx);
            };
        };
    };

    if (reflection) {
        sampled.xyz /= sampled.w;
        sampled.w = getReflection(coord).w;
    };

    return sampled;
};

// TODO: Use Texcoord and Material ID's instead of Color, PBR-Map, Emission,  (due, needs only two or one buffers)
void main() { // TODO: explicit sampling 
    const ivec2 size = imageSize(writeImages[DIFFUSED]), samplep = ivec2(gl_GlobalInvocationID.xy);
    const  vec4 dataflat = getData(samplep);
    const uvec4 datapass = floatBitsToUint(dataflat);
    const  vec4 position = getPosition(samplep);

    // 
    const vec2 texcoord = unpackHalf2x16(datapass.x);
    const bool isSkybox = uintBitsToFloat(datapass.z) <= 0.f;

    // 
    const MaterialUnit unit = materials[0u].data[datapass.y];
          vec4 diffused = toLinear(unit. diffuseTexture >= 0 ? texture(textures[nonuniformEXT(unit. diffuseTexture)],texcoord.xy) : unit.diffuse);
          vec4 emission = toLinear(unit.emissionTexture >= 0 ? texture(textures[nonuniformEXT(unit.emissionTexture)],texcoord.xy) : unit.emission);
          vec4 normaled = unit. normalsTexture >= 0 ? texture(textures[nonuniformEXT(unit. normalsTexture)],texcoord.xy) : unit.normals;
          vec4 specular = unit.specularTexture >= 0 ? texture(textures[nonuniformEXT(unit.specularTexture)],texcoord.xy) : unit.specular;

    // 
    diffused.xyz = max(diffused.xyz - emission.xyz, 0.f.xxx);
    if (isSkybox) { diffused.xyz = 0.f.xxx, emission.xyz = gSkyColor; };

    // 
    const vec3 camera = vec4(position.xyz,1.f)*modelview;
    const vec3 raydir = (modelview * normalize(camera.xyz)).xyz;
    const vec3 origin = getPosition(samplep).xyz;
    const vec3 normal = getNormal(samplep).xyz;

    // 
#ifndef LATE_STAGE
    vec4 reflects = vec4(0.f.xxxx);
    vec4 coloring = getDenoised(samplep, false, 9);
#else // 
    int denDepth = 3;
    if (specular.y > 0.3333f) denDepth = 5;
    if (specular.y > 0.6666f) denDepth = 7;
    if (specular.y > 0.9999f) denDepth = 9;
    vec4 reflects = getDenoised(samplep,  true, denDepth);
    vec4 coloring = vec4(0.f.xxxx);
#endif

    // 
    if (reflects.w <= 0.f) { reflects = vec4(0.f.xxx,0.f); };
    if (coloring.w <= 0.f) { coloring = vec4(0.f.xxx,1.f); };
    coloring = max(coloring, 0.f.xxxx);
    reflects = max(reflects, 0.f.xxxx);

    // 
    const float inIOR = 1.f, outIOR = 1.6666f;
    const float frefl = mix(clamp(pow(1.0f + dot(raydir.xyz, normal.xyz), outIOR/inIOR), 0.f, 1.f) * 0.3333f, 1.f, specular.z) * (isSkybox ? 0.f : 1.f);

    // Currently NOT denoised! (impolated with previous frame)
    vec4 currentReflection = getReflection(samplep), previousReflection = getPReflection(samplep);
    previousReflection = (previousReflection/max(previousReflection.w,1.f));
     currentReflection = ( currentReflection/max( currentReflection.w,1.f));

    // Can't denoised! Going deeper than "opaque" types... mixing with main color... 
    vec4 transpar = getTransparent(samplep);
    float alpha = transpar.w;//(1.f-diffused.w) * (isSkybox ? 0.f : 1.f);

#ifndef LATE_STAGE
    if (frefl > 0.f) {
        imageStore(writeImages[REFLECLR], mapc(samplep), reflects = vec4(clamp(mix(previousReflection.xyz/max(previousReflection.w,1.f),currentReflection.xyz/max(currentReflection.w,1.f),0.5f.xxx),0.f.xxx,1.f.xxx),1.f)); // Smoothed Reflections
    };
    imageStore(writeBuffer[RENDERED],     (samplep), vec4((coloring.xyz/max(coloring.w,1.f))*(diffused.xyz/max(diffused.w,1.f))+max(emission.xyz,0.f.xxx),1.f));
    //imageStore(writeBuffer[RENDERED],   (samplep), vec4(mix((coloring.xyz/max(coloring.w,1.f))*(diffused.xyz/max(diffused.w,1.f))+max(emission.xyz,0.f.xxx),(reflects.xyz/max(reflects.w,1.f)),frefl),1.f));
#else
    imageStore(writeBuffer[RENDERED],     (samplep), vec4(clamp(mix(imageLoad(writeBuffer[RENDERED], samplep).xyz, transpar.xyz/max(transpar.w,1.f), alpha), 0.f.xxx, 1.f.xxx), 1.f));
    imageStore(writeBuffer[RENDERED],     (samplep), vec4(clamp(mix(imageLoad(writeBuffer[RENDERED], samplep).xyz, reflects.xyz/max(reflects.w,1.f), frefl), 0.f.xxx, 1.f.xxx), 1.f));
    //imageStore(writeBuffer[RENDERED],   (samplep), vec4(mix((coloring.xyz/max(coloring.w,1.f))*(diffused.xyz/max(diffused.w,1.f))+max(emission.xyz,0.f.xxx),(reflects.xyz/max(reflects.w,1.f)),frefl),1.f));
#endif

};
