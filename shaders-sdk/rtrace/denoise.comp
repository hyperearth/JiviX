#version 460 core // #
#extension GL_GOOGLE_include_directive          : require
#include "./driver.glsl"

// 
//layout ( location = 0 ) in vec2 vcoord;
//layout ( location = 0 ) out vec4 uFragColor;
layout (local_size_x = 16u, local_size_y = 12u) in; 

// 
vec4 getIndirect   (in ivec2 map) { const ivec2 size = imageSize(writeImages[DIFFUSED]); return imageLoad(writeImages[DIFFUSED],ivec2(map.x,size.y-map.y-1)); };
vec4 getNormal     (in ivec2 map) { const ivec2 size = imageSize(writeImages[MAPNORML]); return imageLoad(writeImages[MAPNORML],ivec2(map.x,size.y-map.y-1)); };
vec4 getPosition   (in ivec2 map) { const ivec2 size = imageSize(writeImages[POSITION]); return imageLoad(writeImages[POSITION],ivec2(map.x,size.y-map.y-1)); };
vec4 getReflection (in ivec2 map) { const ivec2 size = imageSize(writeImages[REFLECLR]); return imageLoad(writeImages[REFLECLR],ivec2(map.x,size.y-map.y-1)); };

// Resampling Data
vec4 getPReflection(in ivec2 map) { const ivec2 size = imageSize(writeImages[REFLECTP]); return imageLoad(writeImages[REFLECTP],ivec2(map.x,size.y-map.y-1)); };

// 
void setColor      (in ivec2 map, in vec4 color) { const ivec2 size = imageSize(writeImages[COLORING]); imageStore(writeImages[COLORING],ivec2(map.x,size.y-map.y-1),color); };
void setReflection (in ivec2 map, in vec4 color) { const ivec2 size = imageSize(writeImages[REFLECLR]); imageStore(writeImages[REFLECLR],ivec2(map.x,size.y-map.y-1),color); };

// FOR REPLACEMENT by Texcoord, Material ID, Data
vec4 getEmission   (in ivec2 map) { const ivec2 size = imageSize(writeImages[EMISSION]); return imageLoad(writeImages[EMISSION],ivec2(map.x,size.y-map.y-1)); };
vec4 getColor      (in ivec2 map) { const ivec2 size = imageSize(writeImages[COLORING]); return imageLoad(writeImages[COLORING],ivec2(map.x,size.y-map.y-1)); };

// 
vec4 getDenoised(in ivec2 coord, in bool reflection, in uint maxc) {
    vec4 centerNormal = getNormal(coord);
    vec3 centerOrigin = world2screen(getPosition(coord).xyz);

    vec4 sampled = 0.f.xxxx; int scount = 0;
    vec4 centerc = getIndirect(coord);
    for (uint x=0;x<maxc;x++) {
        for (uint y=0;y<maxc;y++) {
            ivec2 map = coord+ivec2(x-(maxc>>1),y-(maxc>>1));
            vec4 nsample = getNormal(map);
            vec3 psample = world2screen(getPosition(map).xyz);

            if (dot(nsample.xyz,centerNormal.xyz) >= 0.5f && distance(psample.xyz,centerOrigin.xyz) < 0.01f && abs(centerOrigin.z-psample.z) < 0.005f || (x == (maxc>>1) && y == (maxc>>1)) || centerc.w <= 0.0001f) {
                vec4 samp = 0.f.xxxx;
                if (reflection) {
                    samp = vec4(getReflection(map).xyz,1.f);
                } else {
                    samp = getIndirect(map);
                };

                sampled += samp;
                //sampled += clamp(samp/max(samp.w,1.f),0.f.xxxx,1.f.xxxx);
            };
        };
    };

    if (reflection) {
        sampled.xyz /= sampled.w;
        sampled.w = getReflection(coord).w;
    };

    return sampled;
};

// TODO: Use Texcoord and Material ID's instead of Color, PBR-Map, Emission,  (due, needs only two or one buffers)
void main() { // TODO: explicit sampling 
    const ivec2 size = imageSize(writeImages[DIFFUSED]), samplep = ivec2(gl_GlobalInvocationID.xy);
    const vec4 emission = getEmission(samplep);
    const vec4 specular = vec4(vec3(0.f,0.f,0.f),1.f); // Specular Map
    const vec4 diffused = getColor(samplep);
    const vec4 position = getPosition(samplep);

    // 
    vec3 camera = vec4(position.xyz,1.f)*modelview;
    vec3 raydir = (modelview * normalize(camera.xyz)).xyz;
    vec3 origin = worldsSample.xyz;
    vec3 normal = normalSample.xyz;
    vec3 geonrm = normalSample.xyz;

    // 
    int denDepth = 3;
    if (specular.y > 0.3333f) denDepth = 5;
    if (specular.y > 0.6666f) denDepth = 7;
    if (specular.y > 0.9999f) denDepth = 9;

    // 
    vec4 coloring = getDenoised(samplep, false, 9);
    vec4 reflects = getDenoised(samplep,  true, denDepth);
    if (reflects.w <= 0.f) { reflects = vec4(0.f.xxx,0.f); };
    if (coloring.w <= 0.f) { coloring = vec4(0.f.xxx,1.f); };
    coloring = max(coloring, 0.f.xxxx);
    reflects = max(reflects, 0.f.xxxx);

    // 
    const float inIOR = 1.f, outIOR = 1.6666f;
    const float frefl = mix(clamp(pow(1.0f + dot(raydir.xyz, normal.xyz), outIOR/inIOR), 0.f, 1.f) * 0.3333f, 1.f, specular.z);

    // Currently NOT denoised! (impolated with previous frame)
    vec4 currentReflection = getReflection(samplep), previousReflection = getPReflection(samplep);
    imageStore( writeImages[REFLECLR], samplep, reflects = vec4(clamp(mix(previousReflection.xyz/max(previousReflection.xyz,1.f),currentReflection.xyz/max(currentReflection.xyz,1.f),0.5f.xxx),0.f.xxx,1.f.xxx),1.f)); // Smoothed Reflections

    // Final Result? Planned to move reflection pass...
    imageStore(writeBuffers[RENDERED], samplep, vec4(mix((coloring.xyz/max(coloring.w,1.f))*(diffused.xyz/max(diffused.w,1.f))+max(emission.xyz,0.f.xxx),(reflects.xyz/max(reflects.w,1.f)),frefl),1.f));
};
